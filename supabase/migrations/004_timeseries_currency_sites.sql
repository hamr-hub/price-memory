-- Extensions
create extension if not exists pg_trgm;
create extension if not exists timescaledb;

-- JSONB attributes
alter table if exists public.products add column if not exists attributes jsonb;
create index if not exists idx_products_attributes_gin on public.products using gin (attributes);

-- SKUs table and prices.sku_id
create table if not exists public.skus (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  asin text,
  name text,
  url text,
  attributes jsonb,
  created_at timestamptz default now() not null,
  unique(product_id, asin)
);
create index if not exists idx_skus_product on public.skus(product_id);
create index if not exists idx_skus_attributes_gin on public.skus using gin (attributes);

alter table if exists public.prices add column if not exists sku_id bigint references public.skus(id) on delete cascade;
create index if not exists idx_prices_sku_created on public.prices(sku_id, created_at desc);

-- Tasks source and payload
alter table if exists public.tasks add column if not exists source_url text;
alter table if exists public.tasks add column if not exists request_payload jsonb;
create index if not exists idx_tasks_pending on public.tasks(status) where status = 'pending';

-- Hypertable and continuous aggregates
select public.create_hypertable('public.prices', 'created_at', if_not_exists => true);

create materialized view if not exists public.mv_prices_1h
with (timescaledb.continuous) as
select time_bucket('1 hour', created_at) as bucket,
       product_id,
       avg(price) as avg_price,
       min(price) as min_price,
       max(price) as max_price,
       count(*) as samples
from public.prices
group by product_id, bucket
with data;
create index if not exists idx_mv_prices_1h_product_bucket on public.mv_prices_1h(product_id, bucket desc);

create materialized view if not exists public.mv_prices_1d
with (timescaledb.continuous) as
select time_bucket('1 day', created_at) as bucket,
       product_id,
       avg(price) as avg_price,
       min(price) as min_price,
       max(price) as max_price,
       count(*) as samples
from public.prices
group by product_id, bucket
with data;
create index if not exists idx_mv_prices_1d_product_bucket on public.mv_prices_1d(product_id, bucket desc);

-- Exchange rates and conversion RPC
create table if not exists public.exchange_rates (
  currency text primary key,
  rate_to_usd numeric(18,8) not null,
  updated_at timestamptz default now() not null
);
alter table public.exchange_rates enable row level security;
create policy "exchange_rates_select_all" on public.exchange_rates for select to authenticated using (true);
create index if not exists idx_exchange_rates_currency on public.exchange_rates(currency);

create or replace function public.rpc_convert_price(amount numeric, from_currency text, to_currency text)
returns numeric as $$
  with rates as (
    select
      (select rate_to_usd from public.exchange_rates where currency = from_currency) as from_rate,
      (select rate_to_usd from public.exchange_rates where currency = to_currency) as to_rate
  )
  select case
           when to_currency = from_currency then amount
           when (select from_rate from rates) is null or (select to_rate from rates) is null then null
           else amount * (select from_rate from rates) / (select to_rate from rates)
         end;
$$ language sql stable;

create or replace function public.rpc_prices_aggregate(product_ids bigint[], interval text, start_ts timestamptz, end_ts timestamptz)
returns table(bucket timestamptz, product_id bigint, avg_price numeric, min_price numeric, max_price numeric, samples bigint) as $$
  select time_bucket(interval, created_at) as bucket,
         product_id,
         avg(price) as avg_price,
         min(price) as min_price,
         max(price) as max_price,
         count(*) as samples
  from public.prices
  where product_id = any(product_ids)
    and created_at between start_ts and end_ts
  group by product_id, bucket
  order by bucket desc;
$$ language sql stable;

-- Alert trigger on price insert
create or replace function public.evaluate_price_alerts()
returns trigger as $$
begin
  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'price_below:' || new.price::text
  from public.alerts a
  where a.product_id = new.product_id
    and a.rule_type = 'price_below'
    and a.threshold is not null
    and new.price <= a.threshold;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'price_above:' || new.price::text
  from public.alerts a
  where a.product_id = new.product_id
    and a.rule_type = 'price_above'
    and a.threshold is not null
    and new.price >= a.threshold;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'percent_drop:' || round(((prev.price - new.price) / nullif(prev.price, 0)) * 100.0, 2)::text
  from public.alerts a
  join lateral (
    select price from public.prices p
    where p.product_id = a.product_id and p.id <> new.id
    order by p.created_at desc limit 1
  ) as prev on true
  where a.product_id = new.product_id
    and a.rule_type = 'percent_drop'
    and a.percent is not null
    and prev.price > 0
    and ((prev.price - new.price) / prev.price) * 100.0 >= a.percent;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'percent_rise:' || round(((new.price - prev.price) / nullif(prev.price, 0)) * 100.0, 2)::text
  from public.alerts a
  join lateral (
    select price from public.prices p
    where p.product_id = a.product_id and p.id <> new.id
    order by p.created_at desc limit 1
  ) as prev on true
  where a.product_id = new.product_id
    and a.rule_type = 'percent_rise'
    and a.percent is not null
    and prev.price > 0
    and ((new.price - prev.price) / prev.price) * 100.0 >= a.percent;

  return new;
end;
$$ language plpgsql;

drop trigger if exists t_prices_alerts on public.prices;
create trigger t_prices_alerts after insert on public.prices for each row execute procedure public.evaluate_price_alerts();

-- Sites table
create table if not exists public.sites (
  id bigint generated by identity primary key,
  domain text not null,
  name text,
  region_code text,
  currency text,
  created_at timestamptz default now() not null,
  unique(domain)
);
alter table public.sites enable row level security;
create policy "sites_select_all" on public.sites for select to authenticated using (true);
create index if not exists idx_sites_domain on public.sites(domain);

