create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  plan text default 'free' not null,
  api_key text,
  quota_exports_per_day int default 100 not null,
  exports_used_today int default 0 not null,
  last_quota_reset date,
  created_at timestamptz default now() not null
);

create table if not exists public.products (
  id bigint generated by identity primary key,
  name text not null,
  url text not null,
  source_domain text,
  category text,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  unique(url)
);

create table if not exists public.prices (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  price numeric(12,2) not null check (price >= 0),
  currency text default 'CNY' not null,
  created_at timestamptz default now() not null
);
create index if not exists idx_prices_product_created on public.prices(product_id, created_at desc);

create table if not exists public.tasks (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  status text not null check (status in ('pending','running','succeeded','failed')),
  scheduled_at timestamptz,
  started_at timestamptz,
  completed_at timestamptz,
  result_message text,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
create index if not exists idx_tasks_product on public.tasks(product_id);

create table if not exists public.user_follows (
  id bigint generated by identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  created_at timestamptz default now() not null,
  unique(user_id, product_id)
);
create index if not exists idx_user_follows_user on public.user_follows(user_id);
create index if not exists idx_user_follows_product on public.user_follows(product_id);

create table if not exists public.pushes (
  id bigint generated by identity primary key,
  sender_id uuid references public.profiles(id) on delete set null,
  recipient_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint references public.products(id) on delete set null,
  message text not null,
  status text not null default 'unread' check (status in ('unread','delivered','read')),
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
create index if not exists idx_pushes_recipient on public.pushes(recipient_id, status);

create table if not exists public.pools (
  id bigint generated by identity primary key,
  name text not null,
  is_public boolean not null default false,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz default now() not null
);
create unique index if not exists uniq_pools_owner_name on public.pools(owner_user_id, name);

create table if not exists public.pool_products (
  id bigint generated by identity primary key,
  pool_id bigint not null references public.pools(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  unique(pool_id, product_id)
);
create index if not exists idx_pool_products_pool on public.pool_products(pool_id);
create index if not exists idx_pool_products_product on public.pool_products(product_id);

create table if not exists public.collections (
  id bigint generated by identity primary key,
  name text not null,
  owner_user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz default now() not null
);
create index if not exists idx_collections_owner on public.collections(owner_user_id);

create table if not exists public.collection_products (
  id bigint generated by identity primary key,
  collection_id bigint not null references public.collections(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  unique(collection_id, product_id)
);
create index if not exists idx_collection_products_collection on public.collection_products(collection_id);

create table if not exists public.collection_members (
  id bigint generated by identity primary key,
  collection_id bigint not null references public.collections(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  role text not null check (role in ('owner','editor','viewer')),
  unique(collection_id, user_id)
);
create index if not exists idx_collection_members_collection on public.collection_members(collection_id);
create index if not exists idx_collection_members_user on public.collection_members(user_id);

create table if not exists public.alerts (
  id bigint generated by identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  rule_type text not null check (rule_type in ('price_below','price_above','percent_drop','percent_rise')),
  threshold numeric(12,2),
  percent numeric(5,2),
  status text not null default 'active' check (status in ('active','paused')),
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
alter table public.alerts add constraint alerts_rule_requirements check (
  (rule_type in ('price_below','price_above') and threshold is not null and percent is null)
  or (rule_type in ('percent_drop','percent_rise') and percent is not null and threshold is null)
);
create index if not exists idx_alerts_user on public.alerts(user_id);
create index if not exists idx_alerts_product on public.alerts(product_id);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger t_products_updated before update on public.products for each row execute procedure public.set_updated_at();
create trigger t_tasks_updated before update on public.tasks for each row execute procedure public.set_updated_at();
create trigger t_pushes_updated before update on public.pushes for each row execute procedure public.set_updated_at();
create trigger t_alerts_updated before update on public.alerts for each row execute procedure public.set_updated_at();

alter table public.profiles enable row level security;
alter table public.user_follows enable row level security;
alter table public.pushes enable row level security;
alter table public.pools enable row level security;
alter table public.pool_products enable row level security;
alter table public.collections enable row level security;
alter table public.collection_products enable row level security;
alter table public.collection_members enable row level security;
alter table public.alerts enable row level security;
alter table public.products enable row level security;
alter table public.prices enable row level security;
alter table public.tasks enable row level security;

create policy "profiles_select_self" on public.profiles for select using (id = auth.uid());
create policy "profiles_insert_self" on public.profiles for insert with check (id = auth.uid());
create policy "profiles_update_self" on public.profiles for update using (id = auth.uid()) with check (id = auth.uid());

create policy "products_select_all" on public.products for select to authenticated using (true);

create policy "prices_select_all" on public.prices for select to authenticated using (true);

create policy "tasks_select_all" on public.tasks for select to authenticated using (true);

create policy "follows_select_own" on public.user_follows for select to authenticated using (user_id = auth.uid());
create policy "follows_insert_own" on public.user_follows for insert to authenticated with check (user_id = auth.uid());
create policy "follows_delete_own" on public.user_follows for delete to authenticated using (user_id = auth.uid());

create policy "pushes_select_recipient" on public.pushes for select to authenticated using (recipient_id = auth.uid());
create policy "pushes_update_recipient" on public.pushes for update to authenticated using (recipient_id = auth.uid()) with check (recipient_id = auth.uid());

create policy "pools_select_public_or_owner" on public.pools for select to authenticated using (is_public or owner_user_id = auth.uid());
create policy "pools_insert_owner" on public.pools for insert to authenticated with check (owner_user_id = auth.uid());
create policy "pools_update_owner" on public.pools for update to authenticated using (owner_user_id = auth.uid()) with check (owner_user_id = auth.uid());
create policy "pools_delete_owner" on public.pools for delete to authenticated using (owner_user_id = auth.uid());

create policy "pool_products_select_public_or_owner" on public.pool_products for select to authenticated using (
  exists (select 1 from public.pools p where p.id = pool_id and (p.is_public or p.owner_user_id = auth.uid()))
);
create policy "pool_products_insert_owner" on public.pool_products for insert to authenticated with check (
  exists (select 1 from public.pools p where p.id = pool_id and p.owner_user_id = auth.uid())
);
create policy "pool_products_delete_owner" on public.pool_products for delete to authenticated using (
  exists (select 1 from public.pools p where p.id = pool_id and p.owner_user_id = auth.uid())
);

create policy "collections_select_owner" on public.collections for select to authenticated using (owner_user_id = auth.uid());
create policy "collections_insert_owner" on public.collections for insert to authenticated with check (owner_user_id = auth.uid());
create policy "collections_update_owner" on public.collections for update to authenticated using (owner_user_id = auth.uid()) with check (owner_user_id = auth.uid());
create policy "collections_delete_owner" on public.collections for delete to authenticated using (owner_user_id = auth.uid());
create policy "collections_select_member" on public.collections for select to authenticated using (
  exists (select 1 from public.collection_members m where m.collection_id = id and m.user_id = auth.uid())
);

create policy "collection_products_select_member" on public.collection_products for select to authenticated using (
  exists (select 1 from public.collection_members m where m.collection_id = collection_id and m.user_id = auth.uid())
);
create policy "collection_products_insert_owner" on public.collection_products for insert to authenticated with check (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_products_delete_owner" on public.collection_products for delete to authenticated using (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);

create policy "collection_members_select_member" on public.collection_members for select to authenticated using (
  user_id = auth.uid() or exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_members_insert_owner" on public.collection_members for insert to authenticated with check (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_members_delete_owner" on public.collection_members for delete to authenticated using (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);

create policy "alerts_crud_own_select" on public.alerts for select to authenticated using (user_id = auth.uid());
create policy "alerts_crud_own_insert" on public.alerts for insert to authenticated with check (user_id = auth.uid());
create policy "alerts_crud_own_update" on public.alerts for update to authenticated using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy "alerts_crud_own_delete" on public.alerts for delete to authenticated using (user_id = auth.uid());

alter publication supabase_realtime add table public.prices, public.products;

create extension if not exists pg_trgm;
create index if not exists idx_products_name_trgm on public.products using gin (name gin_trgm_ops);
create index if not exists idx_products_url_trgm on public.products using gin (url gin_trgm_ops);
create index if not exists idx_products_category on public.products(category);

create view public.v_latest_prices as
select distinct on (product_id) product_id, id as price_id, price, currency, created_at
from public.prices
order by product_id, created_at desc;

create view public.v_user_follow_products as
select f.user_id, p.*
from public.user_follows f
join public.products p on p.id = f.product_id;

create or replace function public.reset_daily_quota()
returns void as $$
begin
  update public.profiles
  set exports_used_today = 0,
      last_quota_reset = current_date
  where last_quota_reset is distinct from current_date;
end;
$$ language plpgsql;

create or replace function public.rpc_product_daily_prices(product_id bigint, start_date date, end_date date)
returns table(day date, price numeric) as $$
  with daily as (
    select date_trunc('day', created_at)::date as day,
           price,
           row_number() over (partition by date_trunc('day', created_at)::date order by created_at desc) as rn
    from public.prices
    where product_id = rpc_product_daily_prices.product_id
      and created_at::date between start_date and end_date
  )
  select day, price from daily where rn = 1 order by day;
$$ language sql stable;

create or replace function public.rpc_follow_product(product_id bigint)
returns void as $$
begin
  insert into public.user_follows(user_id, product_id)
  values (auth.uid(), rpc_follow_product.product_id)
  on conflict (user_id, product_id) do nothing;
end;
$$ language plpgsql;

create or replace function public.rpc_unfollow_product(product_id bigint)
returns void as $$
begin
  delete from public.user_follows
  where user_id = auth.uid() and product_id = rpc_unfollow_product.product_id;
end;
$$ language plpgsql;
