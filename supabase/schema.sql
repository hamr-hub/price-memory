create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  display_name text,
  plan text default 'free' not null,
  api_key text,
  quota_exports_per_day int default 100 not null,
  exports_used_today int default 0 not null,
  last_quota_reset date,
  created_at timestamptz default now() not null
);

create table if not exists public.products (
  id bigint generated by identity primary key,
  name text not null,
  url text not null,
  source_domain text,
  category text,
  attributes jsonb,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null,
  unique(url)
);

create table if not exists public.skus (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  asin text,
  name text,
  url text,
  attributes jsonb,
  created_at timestamptz default now() not null,
  unique(product_id, asin)
);
create index if not exists idx_skus_product on public.skus(product_id);

create table if not exists public.prices (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  sku_id bigint references public.skus(id) on delete cascade,
  price numeric(12,2) not null check (price >= 0),
  currency text default 'CNY' not null,
  created_at timestamptz default now() not null
);
create index if not exists idx_prices_product_created on public.prices(product_id, created_at desc);
create index if not exists idx_prices_sku_created on public.prices(sku_id, created_at desc);

create table if not exists public.tasks (
  id bigint generated by identity primary key,
  product_id bigint not null references public.products(id) on delete cascade,
  status text not null check (status in ('pending','running','succeeded','failed')),
  source_url text,
  request_payload jsonb,
  scheduled_at timestamptz,
  started_at timestamptz,
  completed_at timestamptz,
  result_message text,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
create index if not exists idx_tasks_product on public.tasks(product_id);
create index if not exists idx_tasks_pending on public.tasks(status) where status = 'pending';

create table if not exists public.user_follows (
  id bigint generated by identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  created_at timestamptz default now() not null,
  unique(user_id, product_id)
);
create index if not exists idx_user_follows_user on public.user_follows(user_id);
create index if not exists idx_user_follows_product on public.user_follows(product_id);

create table if not exists public.pushes (
  id bigint generated by identity primary key,
  sender_id uuid references public.profiles(id) on delete set null,
  recipient_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint references public.products(id) on delete set null,
  message text not null,
  status text not null default 'pending' check (status in ('pending','accepted','rejected','unread','delivered','read')),
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
create index if not exists idx_pushes_recipient on public.pushes(recipient_id, status);

create table if not exists public.pools (
  id bigint generated by identity primary key,
  name text not null,
  is_public boolean not null default false,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz default now() not null
);
create unique index if not exists uniq_pools_owner_name on public.pools(owner_user_id, name);

create table if not exists public.pool_products (
  id bigint generated by identity primary key,
  pool_id bigint not null references public.pools(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  unique(pool_id, product_id)
);
create index if not exists idx_pool_products_pool on public.pool_products(pool_id);
create index if not exists idx_pool_products_product on public.pool_products(product_id);

create table if not exists public.collections (
  id bigint generated by identity primary key,
  name text not null,
  owner_user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz default now() not null
);
create index if not exists idx_collections_owner on public.collections(owner_user_id);

create table if not exists public.collection_products (
  id bigint generated by identity primary key,
  collection_id bigint not null references public.collections(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  unique(collection_id, product_id)
);
create index if not exists idx_collection_products_collection on public.collection_products(collection_id);

create table if not exists public.collection_members (
  id bigint generated by identity primary key,
  collection_id bigint not null references public.collections(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  role text not null check (role in ('owner','editor','viewer')),
  unique(collection_id, user_id)
);
create index if not exists idx_collection_members_collection on public.collection_members(collection_id);
create index if not exists idx_collection_members_user on public.collection_members(user_id);

create table if not exists public.alerts (
  id bigint generated by identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  rule_type text not null check (rule_type in ('price_below','price_above','percent_drop','percent_rise')),
  threshold numeric(12,2),
  percent numeric(5,2),
  status text not null default 'active' check (status in ('active','paused')),
  channel text,
  cooldown_minutes int,
  last_triggered_at timestamptz,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);
alter table public.alerts add constraint alerts_rule_requirements check (
  (rule_type in ('price_below','price_above') and threshold is not null and percent is null)
  or (rule_type in ('percent_drop','percent_rise') and percent is not null and threshold is null)
);
create index if not exists idx_alerts_user on public.alerts(user_id);
create index if not exists idx_alerts_product on public.alerts(product_id);

create table if not exists public.alert_events (
  id bigint generated by identity primary key,
  alert_id bigint not null references public.alerts(id) on delete cascade,
  product_id bigint not null references public.products(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  price numeric(12,2) not null,
  created_at timestamptz not null default now(),
  message text,
  channel text,
  push_id bigint references public.pushes(id) on delete set null
);
create index if not exists idx_alert_events_alert on public.alert_events(alert_id);

create or replace function public.set_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

create trigger t_products_updated before update on public.products for each row execute procedure public.set_updated_at();
create trigger t_tasks_updated before update on public.tasks for each row execute procedure public.set_updated_at();
create trigger t_pushes_updated before update on public.pushes for each row execute procedure public.set_updated_at();
create trigger t_alerts_updated before update on public.alerts for each row execute procedure public.set_updated_at();

alter table public.user_follows enable row level security;
alter table public.pushes enable row level security;
alter table public.pools enable row level security;
alter table public.pool_products enable row level security;
alter table public.collections enable row level security;
alter table public.collection_products enable row level security;
alter table public.collection_members enable row level security;
alter table public.alerts enable row level security;
alter table public.products enable row level security;
alter table public.prices enable row level security;
alter table public.tasks enable row level security;
alter table public.skus enable row level security;

create policy "products_select_all" on public.products for select to authenticated using (true);
create policy "skus_select_all" on public.skus for select to authenticated using (true);

create policy "prices_select_all" on public.prices for select to authenticated using (true);

create policy "tasks_select_all" on public.tasks for select to authenticated using (true);

drop policy if exists "follows_select_all" on public.user_follows;
drop policy if exists "follows_insert_all" on public.user_follows;
drop policy if exists "follows_delete_all" on public.user_follows;
create policy "follows_select_own" on public.user_follows for select to authenticated using (user_id = auth.uid());
create policy "follows_insert_own" on public.user_follows for insert to authenticated with check (user_id = auth.uid());
create policy "follows_delete_own" on public.user_follows for delete to authenticated using (user_id = auth.uid());

drop policy if exists "pushes_select_all" on public.pushes;
drop policy if exists "pushes_update_all" on public.pushes;
create policy "pushes_select_inbox_outbox" on public.pushes for select to authenticated using (recipient_id = auth.uid() or sender_id = auth.uid());
create policy "pushes_update_recipient" on public.pushes for update to authenticated using (recipient_id = auth.uid()) with check (recipient_id = auth.uid());
create policy "pushes_update_sender" on public.pushes for update to authenticated using (sender_id = auth.uid()) with check (sender_id = auth.uid());

drop policy if exists "pools_select_all" on public.pools;
drop policy if exists "pools_insert_all" on public.pools;
drop policy if exists "pools_update_all" on public.pools;
drop policy if exists "pools_delete_all" on public.pools;
create policy "pools_select_public_or_owner" on public.pools for select to authenticated using (is_public or owner_user_id = auth.uid());
create policy "pools_insert_owner" on public.pools for insert to authenticated with check (owner_user_id = auth.uid());
create policy "pools_update_owner" on public.pools for update to authenticated using (owner_user_id = auth.uid()) with check (owner_user_id = auth.uid());
create policy "pools_delete_owner" on public.pools for delete to authenticated using (owner_user_id = auth.uid());

drop policy if exists "pool_products_select_all" on public.pool_products;
drop policy if exists "pool_products_insert_all" on public.pool_products;
drop policy if exists "pool_products_delete_all" on public.pool_products;
create policy "pool_products_select_public_or_owner" on public.pool_products for select to authenticated using (
  exists (select 1 from public.pools p where p.id = pool_id and (p.is_public or p.owner_user_id = auth.uid()))
);
create policy "pool_products_insert_owner" on public.pool_products for insert to authenticated with check (
  exists (select 1 from public.pools p where p.id = pool_id and p.owner_user_id = auth.uid())
);
create policy "pool_products_delete_owner" on public.pool_products for delete to authenticated using (
  exists (select 1 from public.pools p where p.id = pool_id and p.owner_user_id = auth.uid())
);

drop policy if exists "collections_select_all" on public.collections;
drop policy if exists "collections_insert_all" on public.collections;
drop policy if exists "collections_update_all" on public.collections;
drop policy if exists "collections_delete_all" on public.collections;
create policy "collections_select_owner" on public.collections for select to authenticated using (owner_user_id = auth.uid());
create policy "collections_insert_owner" on public.collections for insert to authenticated with check (owner_user_id = auth.uid());
create policy "collections_update_owner" on public.collections for update to authenticated using (owner_user_id = auth.uid()) with check (owner_user_id = auth.uid());
create policy "collections_delete_owner" on public.collections for delete to authenticated using (owner_user_id = auth.uid());
create policy "collections_select_member" on public.collections for select to authenticated using (
  exists (select 1 from public.collection_members m where m.collection_id = id and m.user_id = auth.uid())
);

drop policy if exists "collection_products_select_all" on public.collection_products;
drop policy if exists "collection_products_insert_all" on public.collection_products;
drop policy if exists "collection_products_delete_all" on public.collection_products;
create policy "collection_products_select_member" on public.collection_products for select to authenticated using (
  exists (select 1 from public.collection_members m where m.collection_id = collection_id and m.user_id = auth.uid())
);
create policy "collection_products_insert_owner" on public.collection_products for insert to authenticated with check (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_products_delete_owner" on public.collection_products for delete to authenticated using (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);

drop policy if exists "collection_members_select_all" on public.collection_members;
drop policy if exists "collection_members_insert_all" on public.collection_members;
drop policy if exists "collection_members_delete_all" on public.collection_members;
create policy "collection_members_select_member" on public.collection_members for select to authenticated using (
  user_id = auth.uid() or exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_members_insert_owner" on public.collection_members for insert to authenticated with check (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);
create policy "collection_members_delete_owner" on public.collection_members for delete to authenticated using (
  exists (select 1 from public.collections c where c.id = collection_id and c.owner_user_id = auth.uid())
);

drop policy if exists "alerts_select_all" on public.alerts;
drop policy if exists "alerts_insert_all" on public.alerts;
drop policy if exists "alerts_update_all" on public.alerts;
drop policy if exists "alerts_delete_all" on public.alerts;
create policy "alerts_crud_own_select" on public.alerts for select to authenticated using (user_id = auth.uid());
create policy "alerts_crud_own_insert" on public.alerts for insert to authenticated with check (user_id = auth.uid());
create policy "alerts_crud_own_update" on public.alerts for update to authenticated using (user_id = auth.uid()) with check (user_id = auth.uid());
create policy "alerts_crud_own_delete" on public.alerts for delete to authenticated using (user_id = auth.uid());

alter table public.alert_events enable row level security;
drop policy if exists "alert_events_select_all" on public.alert_events;
drop policy if exists "alert_events_insert_all" on public.alert_events;
create policy "alert_events_select_own" on public.alert_events for select to authenticated using (user_id = auth.uid());
create policy "alert_events_insert_own" on public.alert_events for insert to authenticated with check (user_id = auth.uid());

alter publication supabase_realtime add table public.prices, public.products;

create extension if not exists pg_trgm;
create extension if not exists timescaledb;
create index if not exists idx_products_name_trgm on public.products using gin (name gin_trgm_ops);
create index if not exists idx_products_url_trgm on public.products using gin (url gin_trgm_ops);
create index if not exists idx_products_category on public.products(category);
create index if not exists idx_products_attributes_gin on public.products using gin (attributes);
create index if not exists idx_skus_attributes_gin on public.skus using gin (attributes);

create table if not exists public.sites (
  id bigint generated by identity primary key,
  domain text not null,
  name text,
  region_code text,
  currency text,
  created_at timestamptz default now() not null,
  unique(domain)
);
alter table public.sites enable row level security;
create policy "sites_select_all" on public.sites for select to authenticated using (true);
create index if not exists idx_sites_domain on public.sites(domain);

create view public.v_latest_prices as
select distinct on (product_id) product_id, id as price_id, price, currency, created_at
from public.prices
order by product_id, created_at desc;

create view public.v_user_follow_products as
select f.user_id, p.*
from public.user_follows f
join public.products p on p.id = f.product_id;

create or replace function public.reset_daily_quota()
returns void as $$
begin
  update public.profiles
  set exports_used_today = 0,
      last_quota_reset = current_date
  where last_quota_reset is distinct from current_date;
end;
$$ language plpgsql;

select public.create_hypertable('public.prices', 'created_at', if_not_exists => true);

create materialized view if not exists public.mv_prices_1h
with (timescaledb.continuous) as
select time_bucket('1 hour', created_at) as bucket,
       product_id,
       avg(price) as avg_price,
       min(price) as min_price,
       max(price) as max_price,
       count(*) as samples
from public.prices
group by product_id, bucket
with data;
create index if not exists idx_mv_prices_1h_product_bucket on public.mv_prices_1h(product_id, bucket desc);

create materialized view if not exists public.mv_prices_1d
with (timescaledb.continuous) as
select time_bucket('1 day', created_at) as bucket,
       product_id,
       avg(price) as avg_price,
       min(price) as min_price,
       max(price) as max_price,
       count(*) as samples
from public.prices
group by product_id, bucket
with data;
create index if not exists idx_mv_prices_1d_product_bucket on public.mv_prices_1d(product_id, bucket desc);

create table if not exists public.exchange_rates (
  currency text primary key,
  rate_to_usd numeric(18,8) not null,
  updated_at timestamptz default now() not null
);
alter table public.exchange_rates enable row level security;
create policy "exchange_rates_select_all" on public.exchange_rates for select to authenticated using (true);
create index if not exists idx_exchange_rates_currency on public.exchange_rates(currency);

create or replace function public.rpc_convert_price(amount numeric, from_currency text, to_currency text)
returns numeric as $$
  with rates as (
    select
      (select rate_to_usd from public.exchange_rates where currency = from_currency) as from_rate,
      (select rate_to_usd from public.exchange_rates where currency = to_currency) as to_rate
  )
  select case
           when to_currency = from_currency then amount
           when (select from_rate from rates) is null or (select to_rate from rates) is null then null
           else amount * (select from_rate from rates) / (select to_rate from rates)
         end;
$$ language sql stable;

create or replace function public.rpc_prices_aggregate(product_ids bigint[], interval text, start_ts timestamptz, end_ts timestamptz)
returns table(bucket timestamptz, product_id bigint, avg_price numeric, min_price numeric, max_price numeric, samples bigint) as $$
  select time_bucket(interval, created_at) as bucket,
         product_id,
         avg(price) as avg_price,
         min(price) as min_price,
         max(price) as max_price,
         count(*) as samples
  from public.prices
  where product_id = any(product_ids)
    and created_at between start_ts and end_ts
  group by product_id, bucket
  order by bucket desc;
$$ language sql stable;

create or replace function public.evaluate_price_alerts()
returns trigger as $$
begin
  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'price_below:' || new.price::text
  from public.alerts a
  where a.product_id = new.product_id
    and a.rule_type = 'price_below'
    and a.threshold is not null
    and new.price <= a.threshold;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'price_above:' || new.price::text
  from public.alerts a
  where a.product_id = new.product_id
    and a.rule_type = 'price_above'
    and a.threshold is not null
    and new.price >= a.threshold;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'percent_drop:' || round(((prev.price - new.price) / nullif(prev.price, 0)) * 100.0, 2)::text
  from public.alerts a
  join lateral (
    select price from public.prices p
    where p.product_id = a.product_id and p.id <> new.id
    order by p.created_at desc limit 1
  ) as prev on true
  where a.product_id = new.product_id
    and a.rule_type = 'percent_drop'
    and a.percent is not null
    and prev.price > 0
    and ((prev.price - new.price) / prev.price) * 100.0 >= a.percent;

  insert into public.pushes(recipient_id, product_id, message)
  select a.user_id, a.product_id,
         'percent_rise:' || round(((new.price - prev.price) / nullif(prev.price, 0)) * 100.0, 2)::text
  from public.alerts a
  join lateral (
    select price from public.prices p
    where p.product_id = a.product_id and p.id <> new.id
    order by p.created_at desc limit 1
  ) as prev on true
  where a.product_id = new.product_id
    and a.rule_type = 'percent_rise'
    and a.percent is not null
    and prev.price > 0
    and ((new.price - prev.price) / prev.price) * 100.0 >= a.percent;

  return new;
end;
$$ language plpgsql;

create trigger t_prices_alerts after insert on public.prices for each row execute procedure public.evaluate_price_alerts();

create or replace function public.rpc_product_daily_prices(product_id bigint, start_date date, end_date date)
returns table(day date, price numeric) as $$
  with daily as (
    select date_trunc('day', created_at)::date as day,
           price,
           row_number() over (partition by date_trunc('day', created_at)::date order by created_at desc) as rn
    from public.prices
    where product_id = rpc_product_daily_prices.product_id
      and created_at::date between start_date and end_date
  )
  select day, price from daily where rn = 1 order by day;
$$ language sql stable;

create or replace function public.rpc_product_hourly_prices(product_id bigint, start_ts timestamptz, end_ts timestamptz)
returns table(hour timestamptz, price numeric) as $$
  with hourly as (
    select date_trunc('hour', created_at) as hour,
           price,
           row_number() over (partition by date_trunc('hour', created_at) order by created_at desc) as rn
    from public.prices
    where product_id = rpc_product_hourly_prices.product_id
      and created_at between start_ts and end_ts
  )
  select hour, price from hourly where rn = 1 order by hour;
$$ language sql stable;

create or replace function public.rpc_product_daily_ohlc(product_id bigint, start_date date, end_date date)
returns table(day date, open numeric, close numeric, low numeric, high numeric, avg numeric, count bigint) as $$
  with days as (
    select distinct created_at::date as day
    from public.prices
    where product_id = rpc_product_daily_ohlc.product_id
      and created_at::date between start_date and end_date
  ),
  series as (
    select d.day,
           (select price from public.prices where product_id = rpc_product_daily_ohlc.product_id and created_at::date = d.day order by created_at asc limit 1) as open,
           (select price from public.prices where product_id = rpc_product_daily_ohlc.product_id and created_at::date = d.day order by created_at desc limit 1) as close,
           min(p.price) as low,
           max(p.price) as high,
           avg(p.price) as avg,
           count(*) as count
    from days d
    join public.prices p on p.product_id = rpc_product_daily_ohlc.product_id and p.created_at::date = d.day
    group by d.day
  )
  select * from series order by day asc;
$$ language sql stable;

create or replace function public.rpc_product_hourly_ohlc(product_id bigint, start_ts timestamptz, end_ts timestamptz)
returns table(hour timestamptz, open numeric, close numeric, low numeric, high numeric, avg numeric, count bigint) as $$
  with hours as (
    select distinct date_trunc('hour', created_at) as hour
    from public.prices
    where product_id = rpc_product_hourly_ohlc.product_id
      and created_at between start_ts and end_ts
  ),
  series as (
    select h.hour,
           (select price from public.prices where product_id = rpc_product_hourly_ohlc.product_id and date_trunc('hour', created_at) = h.hour order by created_at asc limit 1) as open,
           (select price from public.prices where product_id = rpc_product_hourly_ohlc.product_id and date_trunc('hour', created_at) = h.hour order by created_at desc limit 1) as close,
           min(p.price) as low,
           max(p.price) as high,
           avg(p.price) as avg,
           count(*) as count
    from hours h
    join public.prices p on p.product_id = rpc_product_hourly_ohlc.product_id and date_trunc('hour', p.created_at) = h.hour
    group by h.hour
  )
  select * from series order by hour asc;
$$ language sql stable;

create view public.v_product_prices_export as
select p.id as product_id,
       p.name as product_name,
       p.url,
       p.category,
       pr.id as price_id,
       pr.price,
       pr.created_at
from public.products p
join public.prices pr on pr.product_id = p.id;

create or replace function public.rpc_product_stats(product_id bigint)
returns table(count bigint, max_price numeric, min_price numeric, avg_price numeric) as $$
  select count(*), max(price), min(price), avg(price)
  from public.prices
  where product_id = rpc_product_stats.product_id;
$$ language sql stable;

create table if not exists public.users (
  id bigint generated by identity primary key,
  username text not null unique,
  display_name text,
  created_at timestamptz not null default now(),
  api_key text,
  plan text default 'basic' not null,
  quota_exports_per_day int default 5,
  exports_used_today int default 0,
  last_quota_reset date,
  auth_uid uuid unique references auth.users(id) on delete set null
);

alter table public.users enable row level security;
create policy "users_select_all" on public.users for select to authenticated using (true);
create policy "users_insert_all" on public.users for insert to authenticated with check (true);

create or replace function public.rpc_follow_product(product_id bigint)
returns void as $$
begin
  insert into public.user_follows(user_id, product_id)
  values (auth.uid(), rpc_follow_product.product_id)
  on conflict (user_id, product_id) do nothing;
end;
$$ language plpgsql;

create or replace function public.rpc_unfollow_product(product_id bigint)
returns void as $$
begin
  delete from public.user_follows
  where user_id = auth.uid() and product_id = rpc_unfollow_product.product_id;
end;
$$ language plpgsql;
